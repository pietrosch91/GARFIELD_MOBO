/* ============================================================================
  SimpleSPIMaster.v by Zhang Jie

-- Description:
  This block is the SPI master interface, implemented in one single entity.
All internal core operations are synchronous to the 'clk', and a spi base clock
is generated by dividing clk down to a frequency that is 2x the spi SCK line
frequency. The divider value is passed as a generic parameter during
instantiation.
  The block is very simple to use, and has parallel inputs and outputs that
behave like AXI4-Stream Interface.
  It is parameterizable via generics for the data width ('N'), SPI mode (CPHA
and CPOL), lookahead prefetch signaling ('PREFETCH'), and spi base clock
division from sclk_i ('SPI_2X_CLK_DIV').
--
SPI CLOCK GENERATION
====================
--
  The clock generation for the SPI SCK is derived from the high-speed 'clk'
clock. The core divides this reference clock to form the SPI base clock, by the
'SPI_2X_CLK_DIV' generic parameter. The user must set the divider value for the
SPI_2X clock, which is 2x the desired SCK frequency.
  All registers in the core are clocked by the high-speed clocks, and clock
enables are used to run the FSM and other logic at lower rates. This
architecture preserves FPGA clock resources like global clock buffers, and
avoids path delays caused by combinatorial clock dividers outputs.
--
PARALLEL WRITE INTERFACE
========================
The parallel interface has an input port 'din' and an output port 'dout'.
Parallel load is controlled using 2 signals: 'din' and 'wr'. 'PREFETCH' clock
cycles is set in advance to synchronize a pipelined memory or fifo to present
the next input data at 'din' in time to have continuous clock at the spi bus, to
allow back-to-back continuous load.
For a pipelined sync RAM, a PREFETCH of 2 cycles allows an address generator to
present the new adress to the RAM in one cycle, and the RAM to respond in one
more cycle, in time for 'din' to be latched by the shifter.
If the user sequencer needs a different value for PREFETCH, the generic can be
altered at instantiation time.
The 'wr' write enable strobe must be valid at least one setup time before the
rising edge of the last SPI clock cycle,
if continuous transmission is intended. If 'wr' is not valid 2 SPI clock cycles
after the last transmitted bit, the interface enters idle state and deasserts
SSEL.
When the interface is idle, 'wr' write strobe loads the data and starts
transmission.
--
PARALLEL WRITE SEQUENCE
=======================
       __    __    __    __    __    __    __
clk __/  \__/  \__/  \__/  \__/  \__/  \__/  \...  -- parallel interface clock
    ______________ ___________________________...
din __old_data____X______new_data_____________...  -- user circuit loads data on 'din' at next 'clk' rising edge
                               _______
wr  __________________________/       \_______...  -- user strobes 'wr' for one cycle of 'clk'
--
--
PARALLEL READ INTERFACE
=======================
An internal buffer is used to copy the internal shift register data to drive the
'dout' port. When a complete word is received, the core shift register is
transferred to the buffer, at the rising edge of the spi clock, 'spi_sck'.
The signal 'dout_valid' is set one 'clk' clock, to directly drive a synchronous
memory or fifo write enable.
When the interface is idle, data at the 'dout' port holds the last word received.
--
PARALLEL READ SEQUENCE
======================
         ______        ______        ______        ______
spi_sck   bit1 \______/ bitN \______/bitN-1\______/bitN-2\__...  -- internal spi 2x base clock
         _    __    __    __    __    __    __    __    __
clk       \__/  \__/  \__/  \__/  \__/  \__/  \__/  \__/  \_...  -- parallel interface clock
         _____________ _____________________________________...  -- 1) rx data is transferred to 'do_buffer_reg'
dout     ___old_data__X__________new_data___________________...  --    after last rx bit, at rising 'spi_sck'.
                       _____
dout_valid ___________/     \_______________________________...  -- 2) 'dout_valid' strobed for 1 'clk' cycles
--
--
The propagation delay of spi_sck and spi_mosi, referred to the internal clock,
is balanced by similar path delays, but the sampling delay of spi_miso imposes
a setup time referred to the sck signal that limits the high frequency of the
interface, for full duplex operation.
--
2018.10.18  extend the bit_count width for N >= 96
=============================================================================*/
module SimpleSPIMaster #(
  parameter N               = 16, // 32bit serial word length is default
  parameter CPOL            = 0,  // SPI mode selection (mode 0 default)
  parameter CPHA            = 1,  // CPOL = clock polarity, CPHA = clock phase.
  parameter DLY_BEF_SCK     = 1,  // Delay Before SPCK
  parameter DLY_BET_CON_TRA = 1,  // Delay Between Consecutive Transfers
  parameter SPI_2X_CLK_DIV  = 2   // for a 100MHz clk, 2 yields a 25MHz SCK
)(
  // parallel interface
  input               clk,        // clock
  input               rst,        // reset
  input   [N-1:0]     din,        // parallel data in
  input               wr,         // user data write enable
  output              ready,      // the last bit is transferred
  output              dout_valid, // data is valid
  output  [N-1:0]     dout,       // parallel data out
  // serial interface
  output              spi_cs,     // external serial input
  output              spi_sck,    // spi bus sck
  output              spi_mosi,   // spi bus mosi output
  input               spi_miso    // spi bus miso input
);

reg [6:0] clk_cnt;
always @(posedge clk) begin
  if(rst) clk_cnt <= 0;
  else
    if(clk_cnt == SPI_2X_CLK_DIV-1) clk_cnt <= 0;
    else clk_cnt <= clk_cnt + 1'b1;
end
wire spi_2x_ce = (clk_cnt == SPI_2X_CLK_DIV-1)? 1'b1:1'b0;

reg core_clk, core_n_clk;
always @(posedge clk) begin
  if(rst) begin
    core_clk <= 0;
    core_n_clk <= 0;
  end
  else
    if(spi_2x_ce) begin // generate the 2 antiphase core clocks
      core_clk <= ~core_clk;
      core_n_clk <= core_clk;
    end
end
// generate the 2 phase core clock enables
wire core_ce = spi_2x_ce & core_n_clk;
wire core_n_ce = spi_2x_ce & core_clk;

// Sampling clock enable generation: generate 'samp_ce' from 'core_ce' or
// 'core_n_ce' depending on CPHA always sample data at the half-cycle of the
// fsm update cell
wire samp_ce = (CPHA == 0)?  core_ce : core_n_ce;

// FSM clock enable generation: generate 'fsm_ce' from core_ce or core_n_ce
// depending on CPHA
// for CPHA=0, latch registers at rising edge of negative core clock enable
// for CPHA=1, latch registers at rising edge of positive core clock enable
wire fsm_ce = (CPHA == 0)? core_n_ce : core_ce;

reg [7:0] bit_count;
reg bit_count_clr;
always @(posedge clk) begin
  if(rst) bit_count <= 0;
  else
    if(fsm_ce)
      if(bit_count_clr) bit_count <= 0;
      else bit_count <= bit_count + 1'b1;
end

reg [N-1:0] tx_buffer;
reg tx_msb;
reg tx_buffer_empty;
reg tx_buffer_shift;
reg rd;
always @(posedge clk) begin
  if(rst) begin
    tx_buffer <= 0;
    tx_buffer_empty <=1;
  end
  else
    if(tx_buffer_empty) begin
      if(wr) begin
        tx_buffer <= din; // parallel data input buffer register
        tx_buffer_empty <=0;
      end
    end
    else begin
      if(rd & samp_ce) tx_buffer_empty <=1;
      if(tx_buffer_shift & fsm_ce) tx_buffer <= {tx_buffer[N-2:0],1'b0};
    end
end

always @(posedge clk) if(fsm_ce) tx_msb <= tx_buffer[N-2];

reg [1:0] state_reg, state_next;
localparam
  IDLE = 0,
  DLYBS = 1,  // The delay from cs valid to the first valid SCK transition
  DATA = 2,
  DLYBCT = 3; // The delay between two consecutive transfers with the same
              //  peripheral without removing the chip select
// State Machine
always @(posedge clk)
  if (rst) state_reg <= IDLE;
  else if(fsm_ce) state_reg <= state_next;

reg spi_sck_o;
reg spi_cs_o;
reg spi_mosi_o;
always @(*) begin
  state_next = IDLE;
  bit_count_clr = 0;
  rd = 0;
  tx_buffer_shift = 0;
  // generate spi_sck from core_clk depending on CPOL
  // for CPOL=0, spi clk has idle LOW
  // CPOL=1, spi clk has idle HIGH
  spi_sck_o = (CPOL == 0)? 1'b0 : 1'b1;
  spi_cs_o = 1;
  spi_mosi_o = tx_buffer[N-1];
  case(state_reg)
    IDLE: begin
      if(~tx_buffer_empty) begin
        if(DLY_BEF_SCK) state_next = DLYBS;
        else state_next = DATA;
      end
      bit_count_clr = 1;
    end
    DLYBS: begin
      if(bit_count == DLY_BEF_SCK-1) begin
        state_next = DATA;
        bit_count_clr = 1;
      end
      else state_next = DLYBS;
      spi_cs_o = 0;
    end
    DATA: begin
      if(bit_count == N-1) begin
        if(DLY_BET_CON_TRA) state_next = DLYBCT;
        else begin
          if(tx_buffer_empty) state_next = IDLE;
          else state_next = DATA;
        end
        rd = 1;
        bit_count_clr = 1;
        spi_mosi_o = tx_msb;
      end
      else begin
        state_next = DATA;
        tx_buffer_shift = 1;
      end
      spi_cs_o = 0;
      spi_sck_o = (CPOL == 1)? core_clk : core_n_clk;
    end
    DLYBCT: begin
      if(bit_count == DLY_BET_CON_TRA-1) begin
        if(~tx_buffer_empty) state_next = DATA;
        else state_next = IDLE;
        bit_count_clr = 1;
      end
      else state_next = DLYBCT;
      spi_cs_o = 0;
    end
    default: state_next = IDLE;
  endcase
end
// always @(*) begin
//   state_next = state_reg;              // next state
//   sh_next = sh_reg;                    // all output signals are assigned to (avoid latches)
//   ssel_ena_next = ssel_ena_reg;        // controls the slave select line
//   sck_ena_next = sck_ena_reg;          // controls the clock enable of spi sck line
//   do_buffer_next = do_buffer_reg;      // output data buffer
//   do_transfer_next = do_transfer_reg;  // output data flag
//   wr_ack_next = wr_ack_reg;            // write acknowledge
//   di_req_next = di_req_reg;            // prefetch data request
//   spi_mosi_o = sh_reg[N-1];            // default to avoid latch inference
//   case(state)
//     (N+1): begin  //this state is to enable SSEL before SCK
//       spi_mosi_o = sh_reg[N-1];       // shift out tx bit from the MSb
//       ssel_ena_next = 1;            // tx in progress: will assert SSEL
//       sck_ena_next = 1;             // enable SCK on next cycle (stays off on first SSEL clock cycle)
//       di_req_next = 0;              // prefetch data request: deassert when shifting data
//       wr_ack_next = 0;              // remove write acknowledge for all but the load stages
//       state_next = state_reg - 1;     // update next state at each sck pulse
//     end
//     (N): begin  //deassert 'di_rdy' and stretch do_valid
//       spi_mosi_o = sh_reg[N-1];         // shift out tx bit from the MSb
//       di_req_next = 0;                  // prefetch data request: deassert when shifting data
//       sh_next[N-1:1] = sh_reg[N-2:0];   // shift inner bits
//       sh_next[0] = rx_bit_reg;          // shift in rx bit into LSb
//       wr_ack_next = 0;                  // remove write acknowledge for all but the load stages
//       state_next = state_reg - 1;       // update next state at each sck pulse
//     end
//     (N-1) downto (PREFETCH+3): begin          // remove 'do_transfer' and shift bits
//       spi_mosi_o = sh_reg[N-1];                     // shift out tx bit from the MSb
//       di_req_next = 0;                            // prefetch data request: deassert when shifting data
//       do_transfer_next = 0;                       // reset 'do_valid' transfer signal
//       sh_next[N-1:1] = sh_reg[N-2:0]; // shift inner bits
//       sh_next[0] = rx_bit_reg;                      // shift in rx bit into LSb
//       wr_ack_next = 0;                            // remove write acknowledge for all but the load stages
//       state_next = state_reg - 1;                   // update next state at each sck pulse
//     end
//     (PREFETCH+2) downto 2: begin // raise prefetch 'di_req_o' signal
//       spi_mosi_o = sh_reg[N-1];             // shift out tx bit from the MSb
//       di_req_next = 1;                    // request data in advance to allow for pipeline delays
//       sh_next[N-1:1] = sh_reg[N-2:0];     // shift inner bits
//       sh_next[0] = rx_bit_reg;              // shift in rx bit into LSb
//       wr_ack_next = 0;                    // remove write acknowledge for all but the load stages
//       state_next = state_reg - 1;           // update next state at each sck pulse
//     end
//     1: begin              // transfer rx data to do_buffer and restart if new data is written
//       spi_mosi_o = sh_reg[N-1];            // shift out tx bit from the MSb
//       di_req_next = 1;                   // request data in advance to allow for pipeline delays
//       do_buffer_next[N-1:1] = sh_reg[N-2:0];   // shift rx data directly into rx buffer
//       do_buffer_next[0] = rx_bit_reg;      // shift last rx bit into rx buffer
//       do_transfer_next = 1;              // signal transfer to do_buffer
//       if(wr == 1) begin                    // load tx register if valid data present at di_i
//         state_next = N;                  // next state is top bit of new data
//         sh_next = di_reg;                // load parallel data from di_reg into shifter
//         sck_ena_next = 1;              // SCK enabled
//         wr_ack_next = 1;               // acknowledge data in transfer
//       end
//       else begin
//         sck_ena_next = 0;              // SCK disabled: tx empty, no data to send
//         wr_ack_next = 0;               // remove write acknowledge for all but the load stages
//         state_next = state_reg - 1;      // update next state at each sck pulse
//       end
//     end
//     0: begin              // idle state: start and end of transmission
//       di_req_next = 1;           // will request data if shifter empty
//       sck_ena_next = 0;          // SCK disabled: tx empty, no data to send
//       if(wren == 1) begin            // load tx register if valid data present at di_i
//         spi_mosi_o = di_reg[N-1];// special case: shift out first tx bit from the MSb (look ahead)
//         ssel_ena_next = 1;     // enable interface SSEL
//         state_next = N+1;        // start from idle: let one cycle for SSEL settling
//         sh_next = di_reg;        // load bits from di_reg into shifter
//         wr_ack_next = 1;       // acknowledge data in transfer
//       end
//       else begin
//         spi_mosi_o = sh_reg[N-1];// shift out tx bit from the MSb
//         ssel_ena_next = 0;     // deassert SSEL: interface is idle
//         wr_ack_next = 0;       // remove write acknowledge for all but the load stages
//         state_next = 0;          // when idle, keep this state
//       end
//     end
//     default: state_next = IDLE;
//   endcase
// end

assign spi_sck = spi_sck_o;
assign spi_cs = spi_cs_o;
assign spi_mosi = spi_mosi_o;
assign ready = tx_buffer_empty;

//sync spi_miso to the FPGA clock using a 2-bits shift register
reg [1:0] spi_miso_r;
always @(posedge clk) spi_miso_r <= {spi_miso_r[0], spi_miso};

reg [1:0] samp_ce_r;
always @(posedge clk) samp_ce_r <= {samp_ce_r[0], samp_ce};

reg [7:0] bit_count_r0, bit_count_r1;
always @(posedge clk) begin
  bit_count_r0 <= bit_count;
  bit_count_r1 <= bit_count_r0;
end

reg [N-1:0] rx_buffer;
reg rx_buffer_valid;
always @(posedge clk) begin
  if(rst) begin
    rx_buffer <= 0;
    rx_buffer_valid <= 0;
  end
  else begin
    if(samp_ce_r[1]) rx_buffer <= {rx_buffer[N-2:0], spi_miso_r[1]};
    if(samp_ce_r[1] & bit_count_r1 == N-1) rx_buffer_valid <= 1;
    else rx_buffer_valid <= 0;
  end
end
assign dout = rx_buffer;
assign dout_valid = rx_buffer_valid;

endmodule
